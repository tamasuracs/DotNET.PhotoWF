using System;
using System.Collections.Generic;
using System.IO;
using System.Text.RegularExpressions;
using System.Windows;
using System.Windows.Media;
using System.Windows.Media.Imaging;

namespace PhotoWF.Common
{
    public class Helper
    {
        /// <summary>
        /// Method that returns the count of the JPG files beneath the given path
        /// </summary>
        /// <param name="path_">The files system path to check</param>
        /// <returns></returns>
        public static int jpgFileCount(string path_)
        {
            var result = 0;
            if ((File.GetAttributes(path_) & FileAttributes.Directory) == FileAttributes.Directory)
            {
                string[] f = Directory.GetFiles(path_, "*.jpg");
                result += f.Length;

                string[] dirs = Directory.GetDirectories(path_);

                foreach (string dir in dirs)
                {
                    result += jpgFileCount(dir);
                }
            }

            return result;
        }

        /// <summary>
        /// Displays statistical info about the processing
        /// </summary>
        /// <param name="path_">Path to be processed</param>
        /// <param name="totalFilesProcessed_">Total number of the files already processed</param>
        /// <param name="filesProcessedInLastBatch_">Number of the items processed in the last batch</param>
        /// <param name="filesToProcess_">Total number of the files to be processed</param>
        /// <param name="ellapsedMillis_">Ellapsed time</param>
        public static void PrintStatistics(string path_, int totalFilesProcessed_, int filesProcessedInLastBatch_, int filesToProcess_, long ellapsedMillis_)
        {

            double percentage = 0;

            if (filesToProcess_ > 0)
            {
                percentage = ((double)totalFilesProcessed_ / filesToProcess_) * 100;
            }

            double avg = 0;
            if (filesProcessedInLastBatch_ > 0)
            {
                avg = ellapsedMillis_ / filesProcessedInLastBatch_;
            }


            System.Console.WriteLine("{0}% ({1}/{2}) - Processing {3} images took {4} seconds (avg Duration: {5} ms) - directory:'{6}'",
                                        (int)percentage,
                                        totalFilesProcessed_,
                                        filesToProcess_,
                                        filesProcessedInLastBatch_,
                                        ellapsedMillis_/1000,
                                        avg,
                                        path_
                                        );
        }

        /// <summary>
        /// Capitalizes the first letters of the passed keys.
        /// </summary>
        /// <param name="keys_">Keys to process</param>
        /// <returns></returns>
        public static string[] capitalizeFirstLetter(IEnumerable<string> keys_)
        {
            List<string> result = new List<string>();
            foreach (string key in keys_)
            {
                if (!string.IsNullOrEmpty(key))
                {
                    var newkey = normalizeKeyword(key);
                    result.Add(newkey);
                }
            }

            return result.ToArray();
        }

        /// <summary>
        /// Normalizing the passed key: only the first letter is capital, the rest are lowercased.
        /// 
        /// Exception: the signature generated by the current program
        /// </summary>
        /// <param name="key_">The key string to process</param>
        /// <returns></returns>
        public static string normalizeKeyword(string key_)
        {
            if (key_ == Constants.PROGRAM_TAG_SIGNATURE)
            {
                return key_;
            }
            key_ = key_.ToLower();

            if (key_.Length > 0)
            {
                char firstChar = Char.ToUpper(key_[0]);
                key_ = key_.Remove(0, 1);
                key_ = firstChar + key_;
            }

            return key_;
        }

        /// <summary>
        /// Regular Expression matching 
        /// </summary>
        /// <param name="input_">Input string</param>
        /// <param name="pattern_">Pattern to match</param>
        /// <returns></returns>
        public static string match(string input_, string pattern_)
        {
            string result = null;

            var regExpPattern = string.Format("{0}", pattern_);
            var regExp = new Regex(regExpPattern, RegexOptions.IgnoreCase);

            Match m = regExp.Match(input_);

            if (m != null && m.Length > 0)
            {
                result = m.ToString();
            }

            return result;
        }

        /// <summary>
        /// Creates a JpgMeta instance for the passed file 
        /// </summary>
        /// <param name="path_">Path of the file - should be JPG</param>
        /// <returns></returns>
        public static JpgMeta createDecoderForImage(string path_)
        {
            Stream originalFile = File.Open(path_, FileMode.Open, FileAccess.Read);
            BitmapCreateOptions createOptions = BitmapCreateOptions.PreservePixelFormat | BitmapCreateOptions.IgnoreColorProfile;
            BitmapDecoder decoder = BitmapDecoder.Create(originalFile, createOptions, BitmapCacheOption.None);

            if (!decoder.CodecInfo.FileExtensions.Contains("jpg"))
            {
                Console.WriteLine("The file you passed in is not a JPEG.");
                return null;
            }

            JpegBitmapEncoder jpgEncoder = new JpegBitmapEncoder();
            BitmapFrame frame = decoder.Frames[0];

            // If you want to add metadata to the image using the InPlaceBitmapMetadataWriter, first add padding:
            if (frame == null || frame.Metadata == null)
            {
                return null;
            }

            var md = frame.Metadata as BitmapMetadata;

            if (md == null)
            {
                return null;
            }

            return new JpgMeta(originalFile, decoder);
        }

        /// <summary>
        /// Extracting the EXIF keywords from the JpgMeta 
        /// </summary>
        /// <param name="meta_">JPG Metadata</param>
        /// <returns></returns>
        public static ICollection<string> getKeywords(JpgMeta meta_)
        {
            HashSet<string> keywords = new HashSet<string>();

            BitmapDecoder original = meta_.Decoder;

            if (original == null)
            {
                return keywords;
            }

            BitmapFrame frame = original.Frames[0];

            // If you want to add metadata to the image using the InPlaceBitmapMetadataWriter, first add padding:
            if (frame == null || frame.Metadata == null)
            {
                return keywords;
            }

            var md = frame.Metadata as BitmapMetadata;

            if (md == null || md.Keywords == null)
            {
                return keywords;
            }

            foreach (string keyword in md.Keywords)
            {
                keywords.Add(keyword);
            }
            return keywords;
        }

        /// <summary>
        /// Extracting the EXIF keywords from the passed file 
        /// </summary>
        /// <param name="path_">Path of the file</param>
        /// <returns></returns>
        public static ICollection<string> getKeywords(string path_)
        {
            using (JpgMeta meta = createDecoderForImage(path_))
            {
                return getKeywords(meta);
            }
        }

        /// <summary>
        /// Checks if the path can be treated as a MAIN folder 
        /// </summary>
        /// <param name="path_">Path to check</param>
        /// <returns></returns>
        public static bool isMainFolder(string path_)
        {
            return (match(path_, Constants.MAIN_FOLDER_PATTERN) != null);
        }

        /// <summary>
        /// Checks if the path can be treated as a BEST folder 
        /// </summary>
        /// <param name="path_">Path to check</param>
        /// <returns></returns>
        public static bool isBestFolder(string path_)
        {
            return (match(path_, Constants.BEST_FOLDER_PATTERN) != null);
        }

        /// <summary>
        /// Processes the path - splits the name of the MIAN folder and generates
        /// key(words) for it.
        /// </summary>
        /// <param name="path_">The path to be checked</param>
        /// <param name="keywordDelimiter_">Character that delimits keywords</param>
        /// <returns></returns>
        public static IEnumerable<string> applyPatternsOnPath(string path_, char keywordDelimiter_)
        {
            path_ = path_.Replace(@"\", Constants.PATH_DELIMITER);
            path_ = path_.Replace(@"/", Constants.PATH_DELIMITER);
            var resultList = new HashSet<string>();
            
            var result = match(path_, Constants.MAIN_FOLDER_PATTERN);

            if (result != null)
            {
                int idxOfMatch = path_.IndexOf(result);
                var keyWordSuffix = path_.Substring(idxOfMatch);

                foreach (string[] pat in Constants.PATH_PATTERNS_TO_ELIMINATE)
                {
                    try
                    {
                        var regExp = new Regex(pat[0], RegexOptions.IgnoreCase);
                        if(regExp.IsMatch(keyWordSuffix))
                        {
                            keyWordSuffix = regExp.Replace(keyWordSuffix, pat[1]);
                        }
                    }
                    catch(Exception ex)
                    {
                        //We don't really care of exceptions this time
                        ;
                    }
                }

                foreach (string delimiter in Constants.DELIMITERS)
                {
                    keyWordSuffix = keyWordSuffix.Replace(delimiter, keywordDelimiter_.ToString());
                }

                string[] keys = keyWordSuffix.Split(keywordDelimiter_);

                foreach (string key in keys)
                {
                    if (key.Length > 0)
                    {
                        resultList.Add(key);
                    }
                }
            }

            return resultList;
        }

        /// <summary>
        /// Populates keywords:
        /// <ul>
        /// <li/>Takes the EXIF keywords from the passed metadata
        /// <li/>Generates EXIF keywords from the path_
        /// <li/>Normalizes the newly generated keywords - only first letter is Capital
        /// <li/>Normalization is executed - if the flag is switched on 
        /// </ul>
        /// </summary>
        /// <param name="metaData_">Metadata</param>
        /// <param name="applyNormalization_">Flag if normalization should be applied or not</param>
        /// <param name="path_">Path of the file to be processed</param>
        /// <param name="keywords_">Extra keywords</param>
        /// <returns></returns>
        public static HashSet<string> populateKeywords(BitmapMetadata metaData_, bool applyNormalization_, string path_ , IEnumerable<string> keywords_ )
        {
             HashSet<string> lst = new HashSet<string>();

            if (metaData_.Keywords != null)
            {
                lst = new HashSet<string>(metaData_.Keywords);
            }

            if (keywords_ != null)
            {
                foreach (string key in keywords_)
                {
                    lst.Add(key);
                }
            }

            if (path_ != null)
            {
                IEnumerable<string> patternKeys = applyPatternsOnPath(path_, ' ');

                foreach (string keyword in patternKeys)
                {
                    lst.Add(keyword);
                }
            }

            var arr = capitalizeFirstLetter(lst);
            lst.Clear();

            Array.ForEach(arr, c => lst.Add(c));
            lst.Add(Constants.PROGRAM_TAG_SIGNATURE);

            if(applyNormalization_)
            {
                foreach (string[] normalizationEntry in Constants.NORMALIZATION_DICT)
                {
                    string badKey = normalizationEntry[0];
                    string correctKey = normalizationEntry[1];

                    string[] lst_arr = new string[lst.Count];
                    lst.CopyTo(lst_arr);

                    for(int i=lst_arr.Length-1; i>0;i--)
                    {
                        string key = lst_arr[i];

                        if (match(key, badKey) != null)
                        {
                            lst.Remove(key);

                            //if correctKey is defined then it should be added
                            if (correctKey != null)
                            {
                                lst.Add(correctKey);
                            }
                        }
                    }
                }
            }

            return lst;
        }

        /// <summary>
        /// Creates a copy from the passed file
        /// </summary>
        /// <param name="srcPath_">Path of the source file</param>
        /// <param name="dstPath_">Path of the destination file</param>
        public static void createCopy(string srcPath_, string dstPath_)
        {
            if (dstPath_ == null
                ||
                srcPath_ == null
                )
            {
                return;
            }

            DirectoryInfo d = new DirectoryInfo(dstPath_);
            var dstPath = Path.Combine(dstPath_, (new FileInfo(srcPath_)).Name);

            try
            {
                if (!d.Exists)
                {
                    d.Create();
                }

                if (!File.Exists(dstPath))
                {
                    File.Copy(srcPath_, dstPath);
                }
                else
                {
                    Console.WriteLine("File exists: '{0}' ", dstPath);
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine("");
                Console.WriteLine("'{0}' file creation failed : {1}", dstPath, ex.Message);
            }
        }
    }
}
